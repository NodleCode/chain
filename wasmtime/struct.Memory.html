<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A WebAssembly linear memory."><meta name="keywords" content="rust, rustlang, rust-lang, Memory"><title>Memory in wasmtime - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings"></script><script src="../storage.js"></script><script src="../crates.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../favicon.svg">
<link rel="alternate icon" type="image/png" href="../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../wasmtime/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><p class="location">Struct Memory</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#implementations">Methods</a><div class="sidebar-links"><a href="#method.data_ptr">data_ptr</a><a href="#method.data_size">data_size</a><a href="#method.data_unchecked">data_unchecked</a><a href="#method.data_unchecked_mut">data_unchecked_mut</a><a href="#method.grow">grow</a><a href="#method.new">new</a><a href="#method.size">size</a><a href="#method.ty">ty</a></div><a class="sidebar-title" href="#trait-implementations">Trait Implementations</a><div class="sidebar-links"><a href="#impl-Clone">Clone</a><a href="#impl-From%3CMemory%3E">From&lt;Memory&gt;</a></div><a class="sidebar-title" href="#synthetic-implementations">Auto Trait Implementations</a><div class="sidebar-links"><a href="#impl-RefUnwindSafe">!RefUnwindSafe</a><a href="#impl-Send">!Send</a><a href="#impl-Sync">!Sync</a><a href="#impl-Unpin">Unpin</a><a href="#impl-UnwindSafe">!UnwindSafe</a></div><a class="sidebar-title" href="#blanket-implementations">Blanket Implementations</a><div class="sidebar-links"><a href="#impl-Any">Any</a><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a><a href="#impl-From%3CT%3E">From&lt;T&gt;</a><a href="#impl-Into%3CU%3E">Into&lt;U&gt;</a><a href="#impl-Pointable">Pointable</a><a href="#impl-Same%3CT%3E">Same&lt;T&gt;</a><a href="#impl-ToOwned">ToOwned</a><a href="#impl-TryFrom%3CU%3E">TryFrom&lt;U&gt;</a><a href="#impl-TryInto%3CU%3E">TryInto&lt;U&gt;</a></div></div><p class="location"><a href="index.html">wasmtime</a></p><div id="sidebar-vars" data-name="Memory" data-ty="struct" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../brush.svg" width="18" height="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" class="help-button">?</button>
                <a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" height="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Struct <a href="index.html">wasmtime</a>::<wbr><a class="struct" href="">Memory</a><button id="copy-path" onclick="copy_path(this)">⎘</button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/wasmtime/externals.rs.html#808-811" title="goto source code">[src]</a></span></h1><div class="docblock type-decl"><pre class="rust struct">pub struct Memory { /* fields omitted */ }</pre></div><div class="docblock"><p>A WebAssembly linear memory.</p>
<p>WebAssembly memories represent a contiguous array of bytes that have a size
that is always a multiple of the WebAssembly page size, currently 64
kilobytes.</p>
<p>WebAssembly memory is used for global data, statics in C/C++/Rust, shadow
stack memory, etc. Accessing wasm memory is generally quite fast!</p>
<h1 id="memory-and-clone" class="section-header"><a href="#memory-and-clone"><code>Memory</code> and <code>Clone</code></a></h1>
<p>Memories are internally reference counted so you can <code>clone</code> a <code>Memory</code>. The
cloning process only performs a shallow clone, so two cloned <code>Memory</code>
instances are equivalent in their functionality.</p>
<h1 id="memory-and-threads" class="section-header"><a href="#memory-and-threads"><code>Memory</code> and threads</a></h1>
<p>It is intended that <code>Memory</code> is safe to share between threads. At this time
this is not implemented in <code>wasmtime</code>, however. This is planned to be
implemented though!</p>
<h1 id="memory-and-safety" class="section-header"><a href="#memory-and-safety"><code>Memory</code> and Safety</a></h1>
<p>Linear memory is a lynchpin of safety for WebAssembly, but it turns out
there are very few ways to safely inspect the contents of a memory from the
host (Rust). This is because memory safety is quite tricky when working with
a <code>Memory</code> and we’re still working out the best idioms to encapsulate
everything safely where it’s efficient and ergonomic. This section of
documentation, however, is intended to help educate a bit what is and isn’t
safe when working with <code>Memory</code>.</p>
<p>For safety purposes you can think of a <code>Memory</code> as a glorified
<code>Rc&lt;UnsafeCell&lt;Vec&lt;u8&gt;&gt;&gt;</code>. There are a few consequences of this
interpretation:</p>
<ul>
<li>
<p>At any time someone else may have access to the memory (hence the <code>Rc</code>).
This could be a wasm instance, other host code, or a set of wasm instances
which all reference a <code>Memory</code>. When in doubt assume someone else has a
handle to your <code>Memory</code>.</p>
</li>
<li>
<p>At any time, memory can be read from or written to (hence the
<code>UnsafeCell</code>). Anyone with a handle to a wasm memory can read/write to it.
Primarily other instances can execute the <code>load</code> and <code>store</code> family of
instructions, as well as any other which modifies or reads memory.</p>
</li>
<li>
<p>At any time memory may grow (hence the <code>Vec&lt;..&gt;</code>). Growth may relocate the
base memory pointer (similar to how <code>vec.push(...)</code> can change the result
of <code>.as_ptr()</code>)</p>
</li>
</ul>
<p>So given that we’re working roughly with <code>Rc&lt;UnsafeCell&lt;Vec&lt;u8&gt;&gt;&gt;</code> that’s a
lot to keep in mind! It’s hopefully though sort of setting the stage as to
what you can safely do with memories.</p>
<p>Let’s run through a few safe examples first of how you can use a <code>Memory</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">wasmtime::Memory</span>;

<span class="kw">fn</span> <span class="ident">safe_examples</span>(<span class="ident">mem</span>: <span class="kw-2">&amp;</span><span class="ident">Memory</span>) {
    <span class="comment">// Just like wasm, it&#39;s safe to read memory almost at any time. The</span>
    <span class="comment">// gotcha here is that we need to be sure to load from the correct base</span>
    <span class="comment">// pointer and perform the bounds check correctly. So long as this is</span>
    <span class="comment">// all self contained here (e.g. not arbitrary code in the middle) we&#39;re</span>
    <span class="comment">// good to go.</span>
    <span class="kw">let</span> <span class="ident">byte</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">mem</span>.<span class="ident">data_unchecked</span>()[<span class="number">0x123</span>] };

    <span class="comment">// Short-lived borrows of memory are safe, but they must be scoped and</span>
    <span class="comment">// not have code which modifies/etc `Memory` while the borrow is active.</span>
    <span class="comment">// For example if you want to read a string from memory it is safe to do</span>
    <span class="comment">// so:</span>
    <span class="kw">let</span> <span class="ident">string_base</span> <span class="op">=</span> <span class="number">0xdead</span>;
    <span class="kw">let</span> <span class="ident">string_len</span> <span class="op">=</span> <span class="number">0xbeef</span>;
    <span class="kw">let</span> <span class="ident">string</span> <span class="op">=</span> <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="ident">bytes</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">mem</span>.<span class="ident">data_unchecked</span>()[<span class="ident">string_base</span>..][..<span class="ident">string_len</span>];
        <span class="kw">match</span> <span class="ident">std::str::from_utf8</span>(<span class="ident">bytes</span>) {
            <span class="prelude-val">Ok</span>(<span class="ident">s</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="ident">s</span>.<span class="ident">to_string</span>(), <span class="comment">// copy out of wasm memory</span>
            <span class="prelude-val">Err</span>(<span class="kw">_</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="macro">panic!</span>(<span class="string">&quot;not valid utf-8&quot;</span>),
        }
    };

    <span class="comment">// Additionally like wasm you can write to memory at any point in time,</span>
    <span class="comment">// again making sure that after you get the unchecked slice you don&#39;t</span>
    <span class="comment">// execute code which could read/write/modify `Memory`:</span>
    <span class="kw">unsafe</span> {
        <span class="ident">mem</span>.<span class="ident">data_unchecked_mut</span>()[<span class="number">0x123</span>] <span class="op">=</span> <span class="number">3</span>;
    }

    <span class="comment">// When working with *borrows* that point directly into wasm memory you</span>
    <span class="comment">// need to be extremely careful. Any functionality that operates on a</span>
    <span class="comment">// borrow into wasm memory needs to be thoroughly audited to effectively</span>
    <span class="comment">// not touch the `Memory` at all</span>
    <span class="kw">let</span> <span class="ident">data_base</span> <span class="op">=</span> <span class="number">0xfeed</span>;
    <span class="kw">let</span> <span class="ident">data_len</span> <span class="op">=</span> <span class="number">0xface</span>;
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">mem</span>.<span class="ident">data_unchecked</span>()[<span class="ident">data_base</span>..][..<span class="ident">data_len</span>];
        <span class="ident">host_function_that_doesnt_touch_memory</span>(<span class="ident">data</span>);

        <span class="comment">// effectively the same rules apply to mutable borrows</span>
        <span class="kw">let</span> <span class="ident">data_mut</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">mem</span>.<span class="ident">data_unchecked_mut</span>()[<span class="ident">data_base</span>..][..<span class="ident">data_len</span>];
        <span class="ident">host_function_that_doesnt_touch_memory</span>(<span class="ident">data</span>);
    }
}</pre></div>
<p>It’s worth also, however, covering some examples of <strong>incorrect</strong>,
<strong>unsafe</strong> usages of <code>Memory</code>. Do not do these things!</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">wasmtime::Memory</span>;

<span class="comment">// NOTE: All code in this function is not safe to execute and may cause</span>
<span class="comment">// segfaults/undefined behavior at runtime. Do not copy/paste these examples</span>
<span class="comment">// into production code!</span>
<span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">unsafe_examples</span>(<span class="ident">mem</span>: <span class="kw-2">&amp;</span><span class="ident">Memory</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="comment">// First and foremost, any borrow can be invalidated at any time via the</span>
    <span class="comment">// `Memory::grow` function. This can relocate memory which causes any</span>
    <span class="comment">// previous pointer to be possibly invalid now.</span>
    <span class="kw">let</span> <span class="ident">pointer</span>: <span class="kw-2">&amp;</span><span class="ident">u8</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">mem</span>.<span class="ident">data_unchecked</span>()[<span class="number">0x100</span>];
    <span class="ident">mem</span>.<span class="ident">grow</span>(<span class="number">1</span>)<span class="question-mark">?</span>; <span class="comment">// invalidates `pointer`!</span>
    <span class="comment">// println!(&quot;{}&quot;, *pointer); // FATAL: use-after-free</span>

    <span class="comment">// Note that the use-after-free also applies to slices, whether they&#39;re</span>
    <span class="comment">// slices of bytes or strings.</span>
    <span class="kw">let</span> <span class="ident">slice</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>] <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">mem</span>.<span class="ident">data_unchecked</span>()[<span class="number">0x100</span>..<span class="number">0x102</span>];
    <span class="ident">mem</span>.<span class="ident">grow</span>(<span class="number">1</span>)<span class="question-mark">?</span>; <span class="comment">// invalidates `slice`!</span>
    <span class="comment">// println!(&quot;{:?}&quot;, slice); // FATAL: use-after-free</span>

    <span class="comment">// Due to the reference-counted nature of `Memory` note that literal</span>
    <span class="comment">// calls to `Memory::grow` are not sufficient to audit for. You&#39;ll need</span>
    <span class="comment">// to be careful that any mutation of `Memory` doesn&#39;t happen while</span>
    <span class="comment">// you&#39;re holding an active borrow.</span>
    <span class="kw">let</span> <span class="ident">slice</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>] <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">mem</span>.<span class="ident">data_unchecked</span>()[<span class="number">0x100</span>..<span class="number">0x102</span>];
    <span class="ident">some_other_function</span>(); <span class="comment">// may invalidate `slice` through another `mem` reference</span>
    <span class="comment">// println!(&quot;{:?}&quot;, slice); // FATAL: maybe a use-after-free</span>

    <span class="comment">// An especially subtle aspect of accessing a wasm instance&#39;s memory is</span>
    <span class="comment">// that you need to be extremely careful about aliasing. Anyone at any</span>
    <span class="comment">// time can call `data_unchecked()` or `data_unchecked_mut()`, which</span>
    <span class="comment">// means you can easily have aliasing mutable references:</span>
    <span class="kw">let</span> <span class="ident">ref1</span>: <span class="kw-2">&amp;</span><span class="ident">u8</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">mem</span>.<span class="ident">data_unchecked</span>()[<span class="number">0x100</span>];
    <span class="kw">let</span> <span class="ident">ref2</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">u8</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">mem</span>.<span class="ident">data_unchecked_mut</span>()[<span class="number">0x100</span>];
    <span class="comment">// *ref2 = *ref1; // FATAL: violates Rust&#39;s aliasing rules</span>

    <span class="comment">// Note that aliasing applies to strings as well, for example this is</span>
    <span class="comment">// not valid because the slices overlap.</span>
    <span class="kw">let</span> <span class="ident">slice1</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> [<span class="ident">u8</span>] <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">mem</span>.<span class="ident">data_unchecked_mut</span>()[<span class="number">0x100</span>..][..<span class="number">3</span>];
    <span class="kw">let</span> <span class="ident">slice2</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> [<span class="ident">u8</span>] <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">mem</span>.<span class="ident">data_unchecked_mut</span>()[<span class="number">0x102</span>..][..<span class="number">4</span>];
    <span class="comment">// println!(&quot;{:?} {:?}&quot;, slice1, slice2); // FATAL: aliasing mutable pointers</span>

    <span class="prelude-val">Ok</span>(())
}</pre></div>
<p>Overall there’s some general rules of thumb when working with <code>Memory</code> and
getting raw pointers inside of it:</p>
<ul>
<li>If you never have a “long lived” pointer into memory, you’re likely in the
clear. Care still needs to be taken in threaded scenarios or when/where
data is read, but you’ll be shielded from many classes of issues.</li>
<li>Long-lived pointers must always respect Rust’a aliasing rules. It’s ok for
shared borrows to overlap with each other, but mutable borrows must
overlap with nothing.</li>
<li>Long-lived pointers are only valid if <code>Memory</code> isn’t used in an unsafe way
while the pointer is valid. This includes both aliasing and growth.</li>
</ul>
<p>At this point it’s worth reiterating again that working with <code>Memory</code> is
pretty tricky and that’s not great! Proposals such as <a href="https://github.com/webassembly/interface-types">interface types</a> are
intended to prevent wasm modules from even needing to import/export memory
in the first place, which obviates the need for all of these safety caveats!
Additionally over time we’re still working out the best idioms to expose in
<code>wasmtime</code>, so if you’ve got ideas or questions please feel free to <a href="https://github.com/bytecodealliance/wasmtime/issues/new">open an
issue</a>!</p>
<h2 id="memory-safety-and-threads" class="section-header"><a href="#memory-safety-and-threads"><code>Memory</code> Safety and Threads</a></h2>
<p>Currently the <code>wasmtime</code> crate does not implement the wasm threads proposal,
but it is planned to do so. It’s additionally worthwhile discussing how this
affects memory safety and what was previously just discussed as well.</p>
<p>Once threads are added into the mix, all of the above rules still apply.
There’s an additional, rule, however, that all reads and writes can
happen <em>concurrently</em>. This effectively means that long-lived borrows into
wasm memory are virtually never safe to have.</p>
<p>Mutable pointers are fundamentally unsafe to have in a concurrent scenario
in the face of arbitrary wasm code. Only if you dynamically know for sure
that wasm won’t access a region would it be safe to construct a mutable
pointer. Additionally even shared pointers are largely unsafe because their
underlying contents may change, so unless <code>UnsafeCell</code> in one form or
another is used everywhere there’s no safety.</p>
<p>One important point about concurrency is that <code>Memory::grow</code> can indeed
happen concurrently. This, however, will never relocate the base pointer.
Shared memories must always have a maximum size and they will be
preallocated such that growth will never relocate the base pointer. The
maximum length of the memory, however, will change over time.</p>
<p>Overall the general rule of thumb for shared memories is that you must
atomically read and write everything. Nothing can be borrowed and everything
must be eagerly copied out.</p>
</div><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor"></a></h2><details class="rustdoc-toggle implementors-toggle" open><summary><h3 id="impl" class="impl"><code class="in-band">impl <a class="struct" href="struct.Memory.html" title="struct wasmtime::Memory">Memory</a></code><a href="#impl" class="anchor"></a><a class="srclink" href="../src/wasmtime/externals.rs.html#813-1010" title="goto source code">[src]</a></h3></summary><div class="impl-items"><h4 id="method.new" class="method"><code>pub fn <a href="#method.new" class="fnname">new</a>(store: &amp;<a class="struct" href="struct.Store.html" title="struct wasmtime::Store">Store</a>, ty: <a class="struct" href="struct.MemoryType.html" title="struct wasmtime::MemoryType">MemoryType</a>) -&gt; <a class="struct" href="struct.Memory.html" title="struct wasmtime::Memory">Memory</a></code><a href="#method.new" class="anchor"></a><a class="srclink" href="../src/wasmtime/externals.rs.html#837-844" title="goto source code">[src]</a></h4><div class="docblock"><p>Creates a new WebAssembly memory given the configuration of <code>ty</code>.</p>
<p>The <code>store</code> argument is a general location for cache information, and
otherwise the memory will immediately be allocated according to the
type’s configuration. All WebAssembly memory is initialized to zero.</p>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">engine</span> <span class="op">=</span> <span class="ident">Engine::default</span>();
<span class="kw">let</span> <span class="ident">store</span> <span class="op">=</span> <span class="ident">Store::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>);

<span class="kw">let</span> <span class="ident">memory_ty</span> <span class="op">=</span> <span class="ident">MemoryType::new</span>(<span class="ident">Limits::new</span>(<span class="number">1</span>, <span class="prelude-val">None</span>));
<span class="kw">let</span> <span class="ident">memory</span> <span class="op">=</span> <span class="ident">Memory::new</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>, <span class="ident">memory_ty</span>);

<span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, <span class="string">&quot;(module (memory (import \&quot;\&quot; \&quot;\&quot;) 1))&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance::new</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[<span class="ident">memory</span>.<span class="ident">into</span>()])<span class="question-mark">?</span>;
<span class="comment">// ...</span></pre></div>
</div><h4 id="method.ty" class="method"><code>pub fn <a href="#method.ty" class="fnname">ty</a>(&amp;self) -&gt; <a class="struct" href="struct.MemoryType.html" title="struct wasmtime::MemoryType">MemoryType</a></code><a href="#method.ty" class="anchor"></a><a class="srclink" href="../src/wasmtime/externals.rs.html#863-865" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns the underlying type of this memory.</p>
<h1 id="examples-1" class="section-header"><a href="#examples-1">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">engine</span> <span class="op">=</span> <span class="ident">Engine::default</span>();
<span class="kw">let</span> <span class="ident">store</span> <span class="op">=</span> <span class="ident">Store::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>);
<span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, <span class="string">&quot;(module (memory (export \&quot;mem\&quot;) 1))&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance::new</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[])<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">memory</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_memory</span>(<span class="string">&quot;mem&quot;</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">ty</span> <span class="op">=</span> <span class="ident">memory</span>.<span class="ident">ty</span>();
<span class="macro">assert_eq!</span>(<span class="ident">ty</span>.<span class="ident">limits</span>().<span class="ident">min</span>(), <span class="number">1</span>);</pre></div>
</div><h4 id="method.data_unchecked" class="method"><code>pub unsafe fn <a href="#method.data_unchecked" class="fnname">data_unchecked</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></code><a href="#method.data_unchecked" class="anchor"></a><a class="srclink" href="../src/wasmtime/externals.rs.html#894-896" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns this memory as a slice view that can be read natively in Rust.</p>
<h1 id="safety" class="section-header"><a href="#safety">Safety</a></h1>
<p>This is an unsafe operation because there is no guarantee that the
following operations do not happen concurrently while the slice is in
use:</p>
<ul>
<li>Data could be modified by calling into a wasm module.</li>
<li>Memory could be relocated through growth by calling into a wasm
module.</li>
<li>When threads are supported, non-atomic reads will race with other
writes.</li>
</ul>
<p>Extreme care need be taken when the data of a <code>Memory</code> is read. The
above invariants all need to be upheld at a bare minimum, and in
general you’ll need to ensure that while you’re looking at slice you’re
the only one who can possibly look at the slice and read/write it.</p>
<p>Be sure to keep in mind that <code>Memory</code> is reference counted, meaning
that there may be other users of this <code>Memory</code> instance elsewhere in
your program. Additionally <code>Memory</code> can be shared and used in any number
of wasm instances, so calling any wasm code should be considered
dangerous while you’re holding a slice of memory.</p>
<p>For more information and examples see the documentation on the
<a href="struct.Memory.html" title="Memory"><code>Memory</code></a> type.</p>
</div><h4 id="method.data_unchecked_mut" class="method"><code>pub unsafe fn <a href="#method.data_unchecked_mut" class="fnname">data_unchecked_mut</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;mut [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></code><a href="#method.data_unchecked_mut" class="anchor"></a><a class="srclink" href="../src/wasmtime/externals.rs.html#913-916" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns this memory as a slice view that can be read and written
natively in Rust.</p>
<h1 id="safety-1" class="section-header"><a href="#safety-1">Safety</a></h1>
<p>All of the same safety caveats of <a href="struct.Memory.html#method.data_unchecked" title="Memory::data_unchecked"><code>Memory::data_unchecked</code></a> apply
here, doubly so because this is returning a mutable slice! As a
double-extra reminder, remember that <code>Memory</code> is reference counted, so
you can very easily acquire two mutable slices by simply calling this
function twice. Extreme caution should be used when using this method,
and in general you probably want to result to unsafe accessors and the
<code>data</code> methods below.</p>
<p>For more information and examples see the documentation on the
<a href="struct.Memory.html" title="Memory"><code>Memory</code></a> type.</p>
</div><h4 id="method.data_ptr" class="method"><code>pub fn <a href="#method.data_ptr" class="fnname">data_ptr</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a></code><a href="#method.data_ptr" class="anchor"></a><a class="srclink" href="../src/wasmtime/externals.rs.html#927-929" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns the base pointer, in the host’s address space, that the memory
is located at.</p>
<p>When reading and manipulating memory be sure to read up on the caveats
of <a href="struct.Memory.html#method.data_unchecked" title="Memory::data_unchecked"><code>Memory::data_unchecked</code></a> to make sure that you can safely
read/write the memory.</p>
<p>For more information and examples see the documentation on the
<a href="struct.Memory.html" title="Memory"><code>Memory</code></a> type.</p>
</div><h4 id="method.data_size" class="method"><code>pub fn <a href="#method.data_size" class="fnname">data_size</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code><a href="#method.data_size" class="anchor"></a><a class="srclink" href="../src/wasmtime/externals.rs.html#937-939" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns the byte length of this memory.</p>
<p>The returned value will be a multiple of the wasm page size, 64k.</p>
<p>For more information and examples see the documentation on the
<a href="struct.Memory.html" title="Memory"><code>Memory</code></a> type.</p>
</div><h4 id="method.size" class="method"><code>pub fn <a href="#method.size" class="fnname">size</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a></code><a href="#method.size" class="anchor"></a><a class="srclink" href="../src/wasmtime/externals.rs.html#942-944" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns the size, in pages, of this wasm memory.</p>
</div><h4 id="method.grow" class="method"><code>pub fn <a href="#method.grow" class="fnname">grow</a>(&amp;self, delta: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>) -&gt; <a class="type" href="../anyhow/type.Result.html" title="type anyhow::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>&gt;</code><a href="#method.grow" class="anchor"></a><a class="srclink" href="../src/wasmtime/externals.rs.html#981-988" title="goto source code">[src]</a></h4><div class="docblock"><p>Grows this WebAssembly memory by <code>delta</code> pages.</p>
<p>This will attempt to add <code>delta</code> more pages of memory on to the end of
this <code>Memory</code> instance. If successful this may relocate the memory and
cause <a href="struct.Memory.html#method.data_ptr" title="Memory::data_ptr"><code>Memory::data_ptr</code></a> to return a new value. Additionally previous
slices into this memory may no longer be valid.</p>
<p>On success returns the number of pages this memory previously had
before the growth succeeded.</p>
<h1 id="errors" class="section-header"><a href="#errors">Errors</a></h1>
<p>Returns an error if memory could not be grown, for example if it exceeds
the maximum limits of this memory.</p>
<h1 id="examples-2" class="section-header"><a href="#examples-2">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">engine</span> <span class="op">=</span> <span class="ident">Engine::default</span>();
<span class="kw">let</span> <span class="ident">store</span> <span class="op">=</span> <span class="ident">Store::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>);
<span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, <span class="string">&quot;(module (memory (export \&quot;mem\&quot;) 1 2))&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance::new</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[])<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">memory</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_memory</span>(<span class="string">&quot;mem&quot;</span>).<span class="ident">unwrap</span>();

<span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">size</span>(), <span class="number">1</span>);
<span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">grow</span>(<span class="number">1</span>)<span class="question-mark">?</span>, <span class="number">1</span>);
<span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">size</span>(), <span class="number">2</span>);
<span class="macro">assert!</span>(<span class="ident">memory</span>.<span class="ident">grow</span>(<span class="number">1</span>).<span class="ident">is_err</span>());
<span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">size</span>(), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">grow</span>(<span class="number">0</span>)<span class="question-mark">?</span>, <span class="number">2</span>);</pre></div>
</div></div></details><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><h3 id="impl-Clone" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.Memory.html" title="struct wasmtime::Memory">Memory</a></code><a href="#impl-Clone" class="anchor"></a><a class="srclink" href="../src/wasmtime/externals.rs.html#807" title="goto source code">[src]</a></h3></summary><div class="impl-items"><h4 id="method.clone" class="method hidden trait-impl"><code>fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone" class="fnname">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.Memory.html" title="struct wasmtime::Memory">Memory</a></code><a href="#method.clone" class="anchor"></a><a class="srclink" href="../src/wasmtime/externals.rs.html#807" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Returns a copy of the value. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone">Read more</a></p>
</div><h4 id="method.clone_from" class="method hidden trait-impl"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from" class="fnname">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Self)</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a href="#method.clone_from" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#130" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><h3 id="impl-From%3CMemory%3E" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Memory.html" title="struct wasmtime::Memory">Memory</a>&gt; for <a class="enum" href="enum.Extern.html" title="enum wasmtime::Extern">Extern</a></code><a href="#impl-From%3CMemory%3E" class="anchor"></a><a class="srclink" href="../src/wasmtime/externals.rs.html#180-184" title="goto source code">[src]</a></h3></summary><div class="impl-items"><h4 id="method.from" class="method hidden trait-impl"><code>fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(r: <a class="struct" href="struct.Memory.html" title="struct wasmtime::Memory">Memory</a>) -&gt; Self</code><a href="#method.from" class="anchor"></a><a class="srclink" href="../src/wasmtime/externals.rs.html#181-183" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div></details></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><h3 id="impl-RefUnwindSafe" class="impl"><code class="in-band">impl !<a class="trait" href="https://doc.rust-lang.org/nightly/std/panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Memory.html" title="struct wasmtime::Memory">Memory</a></code><a href="#impl-RefUnwindSafe" class="anchor"></a></h3><h3 id="impl-Send" class="impl"><code class="in-band">impl !<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Memory.html" title="struct wasmtime::Memory">Memory</a></code><a href="#impl-Send" class="anchor"></a></h3><h3 id="impl-Sync" class="impl"><code class="in-band">impl !<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Memory.html" title="struct wasmtime::Memory">Memory</a></code><a href="#impl-Sync" class="anchor"></a></h3><h3 id="impl-Unpin" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Memory.html" title="struct wasmtime::Memory">Memory</a></code><a href="#impl-Unpin" class="anchor"></a></h3><h3 id="impl-UnwindSafe" class="impl"><code class="in-band">impl !<a class="trait" href="https://doc.rust-lang.org/nightly/std/panic/trait.UnwindSafe.html" title="trait std::panic::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Memory.html" title="struct wasmtime::Memory">Memory</a></code><a href="#impl-UnwindSafe" class="anchor"></a></h3></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><h3 id="impl-Any" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-Any" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#131-135" title="goto source code">[src]</a></h3></summary><div class="impl-items"><h4 id="method.type_id" class="method hidden trait-impl"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></code><a href="#method.type_id" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#132" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><h3 id="impl-Borrow%3CT%3E" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-Borrow%3CT%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#208-213" title="goto source code">[src]</a></h3></summary><div class="impl-items"><h4 id="method.borrow" class="method hidden trait-impl"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>T</code><a href="#method.borrow" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#210" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><h3 id="impl-BorrowMut%3CT%3E" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-BorrowMut%3CT%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#216-220" title="goto source code">[src]</a></h3></summary><div class="impl-items"><h4 id="method.borrow_mut" class="method hidden trait-impl"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T</code><a href="#method.borrow_mut" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#217" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><h3 id="impl-From%3CT%3E" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</code><a href="#impl-From%3CT%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#544-548" title="goto source code">[src]</a></h3></summary><div class="impl-items"><h4 id="method.from-1" class="method hidden trait-impl"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</code><a href="#method.from-1" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#545" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><h3 id="impl-Into%3CU%3E" class="impl"><code class="in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,&nbsp;</span></code><a href="#impl-Into%3CU%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#533-540" title="goto source code">[src]</a></h3></summary><div class="impl-items"><h4 id="method.into" class="method hidden trait-impl"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</code><a href="#method.into" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#537" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><h3 id="impl-Pointable" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="../crossbeam_epoch/atomic/trait.Pointable.html" title="trait crossbeam_epoch::atomic::Pointable">Pointable</a> for T</code><a href="#impl-Pointable" class="anchor"></a><a class="srclink" href="../src/crossbeam_epoch/atomic.rs.html#194-214" title="goto source code">[src]</a></h3></summary><div class="impl-items"><h4 id="associatedconstant.ALIGN" class="associatedconstant hidden trait-impl"><code>pub const <a href="../crossbeam_epoch/atomic/trait.Pointable.html#associatedconstant.ALIGN" class="constant"><b>ALIGN</b></a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code><a href="#associatedconstant.ALIGN" class="anchor"></a><a class="srclink" href="../src/crossbeam_epoch/atomic.rs.html#195" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>The alignment of pointer.</p>
</div><h4 id="associatedtype.Init" class="type trait-impl"><code>type <a href="../crossbeam_epoch/atomic/trait.Pointable.html#associatedtype.Init" class="type">Init</a> = T</code><a href="#associatedtype.Init" class="anchor"></a></h4><div class='docblock'><p>The type for initializers.</p>
</div><h4 id="method.init" class="method hidden trait-impl"><code>pub unsafe fn <a href="../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.init" class="fnname">init</a>(init: &lt;T as <a class="trait" href="../crossbeam_epoch/atomic/trait.Pointable.html" title="trait crossbeam_epoch::atomic::Pointable">Pointable</a>&gt;::<a class="type" href="../crossbeam_epoch/atomic/trait.Pointable.html#associatedtype.Init" title="type crossbeam_epoch::atomic::Pointable::Init">Init</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code><a href="#method.init" class="anchor"></a><a class="srclink" href="../src/crossbeam_epoch/atomic.rs.html#199" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Initializes a with the given initializer. <a href="../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.init">Read more</a></p>
</div><h4 id="method.deref" class="method hidden trait-impl"><code>pub unsafe fn <a href="../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.deref" class="fnname">deref</a>&lt;'a&gt;(ptr: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a </a>T</code><a href="#method.deref" class="anchor"></a><a class="srclink" href="../src/crossbeam_epoch/atomic.rs.html#203" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Dereferences the given pointer. <a href="../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.deref">Read more</a></p>
</div><h4 id="method.deref_mut" class="method hidden trait-impl"><code>pub unsafe fn <a href="../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.deref_mut" class="fnname">deref_mut</a>&lt;'a&gt;(ptr: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a mut </a>T</code><a href="#method.deref_mut" class="anchor"></a><a class="srclink" href="../src/crossbeam_epoch/atomic.rs.html#207" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Mutably dereferences the given pointer. <a href="../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.deref_mut">Read more</a></p>
</div><h4 id="method.drop" class="method hidden trait-impl"><code>pub unsafe fn <a href="../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.drop" class="fnname">drop</a>(ptr: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>)</code><a href="#method.drop" class="anchor"></a><a class="srclink" href="../src/crossbeam_epoch/atomic.rs.html#211" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Drops the object pointed to by the given pointer. <a href="../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.drop">Read more</a></p>
</div></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><h3 id="impl-Same%3CT%3E" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="../typenum/type_operators/trait.Same.html" title="trait typenum::type_operators::Same">Same</a>&lt;T&gt; for T</code><a href="#impl-Same%3CT%3E" class="anchor"></a><a class="srclink" href="../src/typenum/type_operators.rs.html#34-36" title="goto source code">[src]</a></h3></summary><div class="impl-items"><h4 id="associatedtype.Output" class="type trait-impl"><code>type <a href="../typenum/type_operators/trait.Same.html#associatedtype.Output" class="type">Output</a> = T</code><a href="#associatedtype.Output" class="anchor"></a></h4><div class='docblock'><p>Should always be <code>Self</code></p>
</div></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><h3 id="impl-ToOwned" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,&nbsp;</span></code><a href="#impl-ToOwned" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#81-93" title="goto source code">[src]</a></h3></summary><div class="impl-items"><h4 id="associatedtype.Owned" class="type trait-impl"><code>type <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="type">Owned</a> = T</code><a href="#associatedtype.Owned" class="anchor"></a></h4><div class='docblock'><p>The resulting type after obtaining ownership.</p>
</div><h4 id="method.to_owned" class="method hidden trait-impl"><code>pub fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fnname">to_owned</a>(&amp;self) -&gt; T</code><a href="#method.to_owned" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#86" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></p>
</div><h4 id="method.clone_into" class="method hidden trait-impl"><code>pub fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fnname">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T)</code><a href="#method.clone_into" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#90" title="goto source code">[src]</a></h4><div class="item-info hidden"><div class="stab unstable"><details><summary><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>toowned_clone_into</code>)</summary><p>recently added</p>
</details></div></div><div class='docblock hidden'><p>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></p>
</div></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><h3 id="impl-TryFrom%3CU%3E" class="impl"><code class="in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></code><a href="#impl-TryFrom%3CU%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#581-590" title="goto source code">[src]</a></h3></summary><div class="impl-items"><h4 id="associatedtype.Error" class="type trait-impl"><code>type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="type">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></code><a href="#associatedtype.Error" class="anchor"></a></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id="method.try_from" class="method hidden trait-impl"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a href="#method.try_from" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#587" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><h3 id="impl-TryInto%3CU%3E" class="impl"><code class="in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></code><a href="#impl-TryInto%3CU%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#567-576" title="goto source code">[src]</a></h3></summary><div class="impl-items"><h4 id="associatedtype.Error-1" class="type trait-impl"><code>type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="type">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></code><a href="#associatedtype.Error-1" class="anchor"></a></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id="method.try_into" class="method hidden trait-impl"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a href="#method.try_into" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#573" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div></details></div></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../" data-current-crate="wasmtime" data-search-index-js="../search-index.js" data-search-js="../search.js"></div>
    <script src="../main.js"></script></body></html>