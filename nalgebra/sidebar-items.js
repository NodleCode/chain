initSidebarItems({"fn":[["abs","The absolute value of `a`."],["center","The center of two points."],["clamp","Returns a reference to the input value clamped to the interval `[min, max]`."],["convert","Converts an object from one type to an equivalent or more general one."],["convert_ref","Converts an object from one type to an equivalent or more general one."],["convert_ref_unchecked","Use with care! Same as `try_convert` but without any property checks."],["convert_unchecked","Use with care! Same as `try_convert` but without any property checks."],["distance","The distance between two points."],["distance_squared","The squared distance between two points."],["inf","Returns the infimum of `a` and `b`."],["inf_sup","Returns simultaneously the infimum and supremum of `a` and `b`."],["is_convertible","Indicates if `try_convert` will succeed without actually performing the conversion."],["max","Same as `cmp::max`."],["min","Same as `cmp::min`."],["one","Gets the multiplicative identity element."],["partial_clamp","Clamp `value` between `min` and `max`. Returns `None` if `value` is not comparable to `min` or `max`."],["partial_cmp","Compare `a` and `b` using a partial ordering relation."],["partial_ge","Returns `true` iff `a` and `b` are comparable and `a >= b`."],["partial_gt","Returns `true` iff `a` and `b` are comparable and `a > b`."],["partial_le","Returns `true` iff `a` and `b` are comparable and `a <= b`."],["partial_lt","Returns `true` iff `a` and `b` are comparable and `a < b`."],["partial_max","Return the maximum of `a` and `b` if they are comparable."],["partial_min","Return the minimum of `a` and `b` if they are comparable."],["partial_sort2","Sorts two values in increasing order using a partial ordering."],["sup","Returns the supremum of `a` and `b`."],["try_convert","Attempts to convert an object to a more specific one."],["try_convert_ref","Attempts to convert an object to a more specific one."],["wrap","Wraps `val` into the range `[min, max]` using modular arithmetics."],["zero","Gets the additive identity element."]],"macro":[["dmatrix","Construct a dynamic matrix directly from data."],["dvector","Construct a dynamic column vector directly from data."],["matrix","Construct a fixed-size matrix directly from data."],["point","Construct a fixed-size point directly from data."],["unimplemented_or_uninitialized_generic","When “no_unsound_assume_init” is enabled, expands to `unimplemented!()` instead of `new_uninitialized_generic().assume_init()`. Intended as a placeholder, each callsite should be refactored to use uninitialized memory soundly"],["vector","Construct a fixed-size column vector directly from data."]],"mod":[["base","[Reexported at the root of this crate.] Data structures for vector and matrix computations."],["geometry","[Reexported at the root of this crate.] Data structures for points and usual transformations (rotations, isometries, etc.)"],["linalg","[Reexported at the root of this crate.] Factorization of real matrices."]],"struct":[["Complex","A complex number in Cartesian form."]],"trait":[["ClosedAdd","Trait alias for `Add` and `AddAssign` with result of type `Self`."],["ClosedDiv","Trait alias for `Div` and `DivAssign` with result of type `Self`."],["ClosedMul","Trait alias for `Mul` and `MulAssign` with result of type `Self`."],["ClosedSub","Trait alias for `Sub` and `SubAssign` with result of type `Self`."],["ComplexField","Trait shared by all complex fields and its subfields (like real numbers)."],["Field","Trait implemented by fields, i.e., complex numbers and floats."],["RealField","Trait shared by all reals."],["SimdBool","Lane-wise generalization of `bool` for SIMD booleans."],["SimdComplexField","Lane-wise generalisation of `ComplexField` for SIMD complex fields."],["SimdPartialOrd","Lane-wise generalization of the standard `PartialOrd` for SIMD values."],["SimdRealField","Lanewise generalization of `RealField` for SIMD reals."],["SimdValue","Base trait for every SIMD types."]]});